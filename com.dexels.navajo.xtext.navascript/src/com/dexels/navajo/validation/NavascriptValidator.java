/*
 * generated by Xtext 2.24.0
 */
package com.dexels.navajo.validation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import org.apache.log4j.Logger;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.osgi.framework.BundleContext;
import org.osgi.framework.ServiceEvent;
import org.osgi.framework.ServiceListener;

import com.dexels.navajo.navascript.Expression;
import com.dexels.navajo.navascript.InnerBody;
import com.dexels.navajo.navascript.KeyValueArgument;
import com.dexels.navajo.navascript.KeyValueArguments;
import com.dexels.navajo.navascript.Message;
import com.dexels.navajo.navascript.NavascriptPackage;
import com.dexels.navajo.navascript.PropertyArgument;
import com.dexels.navajo.navascript.PropertyArguments;
import com.dexels.navajo.navascript.ScriptIdentifier;
import com.dexels.navajo.navascript.TmlIdentifierLiteral;
import com.dexels.navajo.navascript.TopLevelStatement;
import com.dexels.navajo.navascript.VarElement;
import com.dexels.navajo.navascript.VariableIdentifier;
import com.dexels.navajo.navascript.impl.AdapterMethodImpl;
import com.dexels.navajo.navascript.impl.FunctionIdentifierImpl;
import com.dexels.navajo.navascript.impl.LoopImpl;
import com.dexels.navajo.navascript.impl.MapImpl;
import com.dexels.navajo.navascript.impl.MappableIdentifierImpl;
import com.dexels.navajo.navascript.impl.MappedArrayFieldImpl;
import com.dexels.navajo.navascript.impl.MappedMessageImpl;
import com.dexels.navajo.navascript.impl.MessageImpl;
import com.dexels.navajo.navascript.impl.PropertyImpl;
import com.dexels.navajo.navascript.impl.SetterFieldImpl;
import com.dexels.navajo.navascript.impl.VarImpl;
import com.dexels.navajo.navigation.NavigationUtils;
import com.dexels.navajo.xtext.navascript.navajobridge.AdapterClassDefinition;
import com.dexels.navajo.xtext.navascript.navajobridge.NavajoProxyStub;
import com.dexels.navajo.xtext.navascript.navajobridge.OSGIRuntime;
import com.dexels.navajo.xtext.navascript.navajobridge.ProxyFunctionDefinition;

class FindElementOrder {

	public FindElementOrder(EObject e) {
		this.element = e;
	}
	
	public EObject element;
	public int order = 0;
	
}

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class NavascriptValidator extends AbstractNavascriptValidator implements ServiceListener {

	BundleContext context;

	private static final Logger logger = Logger.getLogger(NavascriptValidator.class);
	
	public NavascriptValidator() {
		context = OSGIRuntime.getDefaultBundleContext();
		context.addServiceListener(this);
		logger.info("In NavascriptValidator: " + context);
	}

	private NavajoProxyStub getNavajoProxyStub() {
		if (  NavajoProxyStub.getInstance() == null ) {
			throw new RuntimeException("NavajoProxyStub not yet activated");
		}
		return  NavajoProxyStub.getInstance();
	}

	@Check
	public void checkFunction(FunctionIdentifierImpl function) {

		String functionName = function.getFunc();
		EList<Expression> arguments = function.getArgs();

		ProxyFunctionDefinition functionDef = getNavajoProxyStub().getFunction(functionName);

		if (functionDef == null) {
			warning("Unknown function: " + functionName, NavascriptPackage.Literals.FUNCTION_IDENTIFIER__FUNC);
			return;
		} 

		List<String> altInputs = functionDef.getInput();
		if ( altInputs.isEmpty() ) { // If there are no inputs specified, return;
			return;
		}
		if ( functionDef.isValidNrInputParameters(arguments.size()) ) {
			return;
		}

		error("Invalid number of input parameters. Valid input: " + functionDef.getInput() , NavascriptPackage.Literals.FUNCTION_IDENTIFIER__ARGS);
	}

	@Check
	public void checkMapDefinition(MapImpl map) {

		String adapterName = map.getAdapterName();
		String objectName = map.getObjectName();

		// If an objectName (old style) is used, ignore check.
		if (objectName != null && !"".equals(objectName)) {
			return;
		}

		if (adapterName != null && !"".equals(adapterName)) {
			if (getNavajoProxyStub().getAdapter(adapterName) == null) {
				warning("Unknown adapter: " + adapterName, NavascriptPackage.Literals.MAP__ADAPTER_NAME);
			}
		}
	}

	private void fieldValidator(EObject mai, String prefix) {
		
		boolean isSetter = false;
		boolean isSetterField = ( mai instanceof SetterFieldImpl );
		if ( mai instanceof SetterFieldImpl ) { // if this is a SetterFieldImpl it can either be a 'setter' or a 'getter'
			SetterFieldImpl sfi = (SetterFieldImpl) mai;
			// If nothing is 'mapped', it is a setter.
			isSetter = sfi.getMappedArray() == null && sfi.getMappedField() == null && sfi.getMappedMessage() == null;
		}		
		String fieldName = NavigationUtils.getFieldFromMappableIdentifier(prefix);
		int level = NavigationUtils.countMappableParentLevel(prefix);
				
		if ( mai.eContainer() instanceof LoopImpl ) { // If current EOBject is a LoopImpl, move one level up.
			mai = mai.eContainer();
		}
		
		EObject parent = NavigationUtils.findFirstMapOrMappedField(mai.eContainer(), level);
	
		AdapterClassDefinition mapdef = NavigationUtils.findAdapterClass(getNavajoProxyStub(), parent);
				
		if (mapdef != null) {

			boolean isValid = ( isSetter ? mapdef.isSetter(fieldName) : mapdef.isGetter(fieldName) );

			
			if (!isValid) {
				if ( mai instanceof LoopImpl ) {
					warning("(1) Unknown mappable field: " + fieldName, NavascriptPackage.Literals.LOOP__MAPPABLE);
					return;
				} else if ( isSetterField ) {
					warning("(2) Unknown mappable field: " + fieldName, NavascriptPackage.Literals.SETTER_FIELD__FIELD);
					return;
				} else {
					warning("(3) Unknown mappable field: " + fieldName, NavascriptPackage.Literals.MAPPABLE_IDENTIFIER__FIELD);
					return;
				}
			}
			
			if ( mai instanceof MappableIdentifierImpl) {
				int numberOfArguments = ((MappableIdentifierImpl) mai).getArgs().size();
				if ( numberOfArguments == 0 ) {
					return;
				}
				List<List<String>> signatures = mapdef.getGetterTypeSignatures(fieldName);
				for (List<String> parameters : signatures) {
					if (parameters.size() == numberOfArguments) {
						return;
					}
				}
			}
			
			if ( mai instanceof SetterFieldImpl) {
				if ( isSetter ) {
					return;
				}
				int numberOfArguments = ((SetterFieldImpl) mai).getArguments().getKeyValueArguments().size();
				if ( numberOfArguments == 0 ) {
					return;
				}
				List<List<String>> signatures = mapdef.getGetterTypeSignatures(fieldName);
				for (List<String> parameters : signatures) {
					if (parameters.size() == numberOfArguments) {
						return;
					}
				}
			}
			
			if ( isSetterField ) {
				error("Invalid number of arguments", NavascriptPackage.Literals.SETTER_FIELD__EXPRESSION_LIST);
			} else {
				error("Invalid number of arguments", NavascriptPackage.Literals.MAPPABLE_IDENTIFIER__ARGS);
			}
		} else {
			if ( isSetterField ) {
				warning("(4) Unknown mappable field: " + fieldName, NavascriptPackage.Literals.SETTER_FIELD__FIELD);
			} else {
				warning("(5) Invalid mappable field: " + fieldName, NavascriptPackage.Literals.MAPPABLE_IDENTIFIER__FIELD);
			}
		}
	}
	
	@Check
	public void checkSetterField(SetterFieldImpl sfi) {
		//System.err.println("In checkSetterField: " + sfi);
		fieldValidator(sfi, sfi.getField());	
	}
	
	@Check
	public void checkMappedMessage(MappedMessageImpl mmi) {
		// No checking need for now I guess.
	}
	
	@Check
	public void checkMappableIdentifier(MappableIdentifierImpl mai) {
		//System.err.println("In checkMappableIdentifier: " + mai);
		fieldValidator(mai, mai.getField());
	}

	private int countPropertiesWithName(String name, EList<EObject> children) {

		int count = 0;

		for (EObject child : children) {
			if (child instanceof PropertyImpl) {
				PropertyImpl prop = (PropertyImpl) child;
				InnerBody ib = NavigationUtils.findInnerBody(prop); // If property has a condition, do not count it.
				if (ib.getCondition() == null && prop.getPropertyName().equals(name)) {
					count++;
				}
			}
			if (!(child instanceof MessageImpl) && child.eContents() != null) {
				count += countPropertiesWithName(name, child.eContents());
			}
		}

		return count;
	}

	/*
	 * Returns true if this message contains this property name.
	 */
	private boolean checkForPropertyName(PropertyImpl checkit, Message m) {
		return countPropertiesWithName(checkit.getPropertyName(), m.eContents()) > 1;
	}

	@Check
	public void checkUniquePropertyName(PropertyImpl property) {
		// Get message.
		Message parent = NavigationUtils.findMessage(property);
		boolean isConstantArrayMessage = parent.getMessageArray() != null && parent.getMessageArray().getArrayMessageElements().size() > 0;
		if ( !isConstantArrayMessage && checkForPropertyName(property, parent)) {
			warning("Duplicate property name in message", NavascriptPackage.Literals.PROPERTY__PROPERTY_NAME);
		}
	}

	@Check
	public void checkUniquePropertyArguments(PropertyImpl property) {

		PropertyArguments arguments = property.getArguments();
		if (arguments != null) {
			EList<PropertyArgument> args = arguments.getArguments();
			Set<String> found = new HashSet<>();
			for ( PropertyArgument pa : args ) {
				if ( found.contains(pa.getClass().getName())) {
					error("Duplicate arguments in property: " + property.getPropertyName(), NavascriptPackage.Literals.PROPERTY__ARGUMENTS);
				}
				found.add(pa.getClass().getName());
			}
		}
	}

	@Check 
	public void checkScriptReference(ScriptIdentifier scriptUrl) {
		String name = scriptUrl.getValue().getScript();
		
		try {
			if ( !NavajoProxyStub.getInstance().getScripts().contains(name) ) {
				error("Cannot find script: " + name, NavascriptPackage.Literals.SCRIPT_IDENTIFIER__SCRIPT);
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	private void checkElementOrder(EObject currentElement, FindElementOrder first, FindElementOrder second, AtomicInteger count) {

		if ( first.order > 0 && second.order > 0  ) {
			return;
		}
		
		if ( currentElement.equals(first.element) ) {
			first.order = count.get();
			return;
		}
		
		if ( currentElement.equals(second.element) ) {
			second.order = count.get();
			return;
		}
		
		count.incrementAndGet();

		EList<EObject> list = currentElement.eContents();
		for ( EObject child : list ) {
			checkElementOrder(child, first, second, count);
		}

	}
	
	private boolean checkParent(EObject child, EObject parent) {
	
		if ( child == null ) {
			return false;
		}		
		EObject currentParent = child.eContainer();
		if ( currentParent != null && currentParent.equals(parent) ) {
			return true;
		} else {
			return checkParent(currentParent, parent);
		}
			
	}
	
	private boolean checkDeclaredBefore(VarImpl var, EObject currentElement) {
	
		EObject rootElement = EcoreUtil2.getRootContainer(currentElement.eContainer());
		
		FindElementOrder firstElt = new FindElementOrder(var);
		FindElementOrder secondElt = new FindElementOrder(currentElement);
		
		checkElementOrder(rootElement, firstElt, secondElt, new AtomicInteger());
		
		EObject conditionBlock = checkVariableInConditionBlock(var);
		
		if ( conditionBlock != null ) {
			// check if currentElement has the same parent. If so, all is fine.
			if ( !checkParent(currentElement, conditionBlock) ) {
				return false;
			} else {
				// no problem, reference in same condition block
			}
		} 
		
		return firstElt.order < secondElt.order;
		
	}
	
	private EObject checkVariableInConditionBlock(VarImpl var) {

		EObject parent = var.eContainer();
		while ( parent != null ) {
			if ( parent instanceof VarElement) {
				VarElement varElement = (VarElement) parent;
				if ( varElement.getCondition() != null ) {
					return varElement;
				}
			}
			if ( parent instanceof InnerBody ) {
				InnerBody innerBody = (InnerBody) parent;
				if ( innerBody.getCondition() != null ) {
					return innerBody;
				}
			}
			if ( parent instanceof TopLevelStatement ) {
				TopLevelStatement topLevel = (TopLevelStatement) parent;
				if ( topLevel.getCondition() != null ) {
					return topLevel;
				}
			}
			parent = parent.eContainer();
		}

		return null;
	}
	
	@Check
	public void checkVariableNameExistence(VariableIdentifier property) {
		if ( !isValidVariable(property, property.getValue()) ) {
			error("Parameter " + property.getValue() + " is not declared (yet)", NavascriptPackage.Literals.VARIABLE_IDENTIFIER__VALUE);
		}
	}
	
	private boolean isValidVariable(EObject eObject, String variableName) {
	
		EObject rootElement = EcoreUtil2.getRootContainer(eObject.eContainer());
		
		List<VarImpl> candidates = EcoreUtil2.getAllContentsOfType(rootElement, VarImpl.class);
		
		if ( candidates.size() == 0 ) {
			return false;
		}
		boolean check = false;
		for ( VarImpl v : candidates) {	
			if ( v.getVarName().equals(variableName) ) {
				check = check || checkDeclaredBefore(v, eObject);
			}
		}
		
		return check;
	}
	
	@Check
	public void checkParameterNameExistence(TmlIdentifierLiteral property) {
	
		String name =  property.getValue().getTml();
		if ( name.startsWith("[/@") ) {
			String stripped = name.replaceAll("\\[", "").replaceAll("\\]", "").replaceAll("/@", "");
			if ( !isValidVariable(property, stripped) ) {
				error("Parameter " + stripped + " is not declared or in other conditional scope only", NavascriptPackage.Literals.TML_IDENTIFIER_LITERAL__VALUE);
			}
		}
	}
	
	@Check
	public void checkMappedMappedArrayFieldImpl(MappedArrayFieldImpl maf) {
		String raw = maf.getField();
		int level = NavigationUtils.countMappableParentLevel(raw);
		String field = NavigationUtils.getFieldFromMappableIdentifier(raw);
		EObject eObject = NavigationUtils.findFirstMapOrMappedField(maf.eContainer(), level);
		AdapterClassDefinition map = NavigationUtils.findAdapterClass(getNavajoProxyStub(), eObject);
		if (map != null) {
			boolean isValid = map.isGetter(field);
			if (!isValid) {
				error("Cannot find field: " + field, NavascriptPackage.Literals.MAPPED_ARRAY_FIELD__FIELD);
			}
		} else {
			error("Cannot find adapter for field: " + raw, NavascriptPackage.Literals.MAPPED_ARRAY_FIELD__FIELD);
		}
	}

	@Check
	public void checkAdapterMethodParameters(AdapterMethodImpl am) {

		try {

			EObject eObject = NavigationUtils.findFirstMapOrMappedField(am.eContainer(), 0);
			if (eObject instanceof MapImpl) {
				MapImpl map = (MapImpl) eObject;
				String adapterName = map.getAdapterName();
				if (adapterName == null || "null".equals(adapterName)) {
					warning("Missing adapter definition for method", NavascriptPackage.Literals.ADAPTER_METHOD__METHOD);
					return;
				}

				KeyValueArguments kvas = am.getArguments();

				AdapterClassDefinition mapdef = getNavajoProxyStub().getAdapter(adapterName);

				if (mapdef == null) {
					return;
				}

				List<String> parameters = new ArrayList<>();

				if (kvas != null) {
					for (KeyValueArgument a : kvas.getKeyValueArguments()) {
						parameters.add(a.getKey());
					}
				}

				String methodName = am.getMethod().substring(1);
				Set<String> missing = mapdef.missingRequiredParameters(methodName, parameters);

				Set<String> unknown = mapdef.unknownParameters(methodName, parameters);

				StringBuffer message = new StringBuffer();
				if (missing.size() > 0) {
					message.append("Missing required parameters: " + missing + ". ");
				}
				if (unknown.size() > 0) {
					message.append("Unknown parameters: " + unknown);
				}
				if (missing.size() > 0 || unknown.size() > 0) {
					error(message.toString(), NavascriptPackage.Literals.ADAPTER_METHOD__METHOD);
				}

			} else {

			}
		} catch (Throwable t) {
			logger.error(t);
		}

	}

	@Override
	public void serviceChanged(ServiceEvent event) {
		//
	}
}
