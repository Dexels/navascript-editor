/*
 * generated by Xtext 2.24.0
 */
package com.dexels.navajo.serializer;

import com.dexels.navajo.navascript.AdapterMethod;
import com.dexels.navajo.navascript.AndOrExpression;
import com.dexels.navajo.navascript.AntiMessage;
import com.dexels.navajo.navascript.ArithmeticSigned;
import com.dexels.navajo.navascript.ArrayElementType;
import com.dexels.navajo.navascript.ArrayType;
import com.dexels.navajo.navascript.BinaryType;
import com.dexels.navajo.navascript.BlockStatements;
import com.dexels.navajo.navascript.BooleanLiteral;
import com.dexels.navajo.navascript.BooleanNegation;
import com.dexels.navajo.navascript.BooleanType;
import com.dexels.navajo.navascript.Break;
import com.dexels.navajo.navascript.BreakParameter;
import com.dexels.navajo.navascript.BreakParameters;
import com.dexels.navajo.navascript.CardinalityArgument;
import com.dexels.navajo.navascript.Check;
import com.dexels.navajo.navascript.CheckAttribute;
import com.dexels.navajo.navascript.ClockTimeType;
import com.dexels.navajo.navascript.Comparison;
import com.dexels.navajo.navascript.ConditionalExpression;
import com.dexels.navajo.navascript.ConditionalExpressions;
import com.dexels.navajo.navascript.CurrentInDoc;
import com.dexels.navajo.navascript.CurrentOutDoc;
import com.dexels.navajo.navascript.CurrentVarDoc;
import com.dexels.navajo.navascript.DateType;
import com.dexels.navajo.navascript.DebugStatement;
import com.dexels.navajo.navascript.Define;
import com.dexels.navajo.navascript.DescriptionArgument;
import com.dexels.navajo.navascript.DirectionArgument;
import com.dexels.navajo.navascript.Equals;
import com.dexels.navajo.navascript.ExpressionLiteral;
import com.dexels.navajo.navascript.Finally;
import com.dexels.navajo.navascript.FloatType;
import com.dexels.navajo.navascript.ForAllIdentifier;
import com.dexels.navajo.navascript.ForAllLiteral;
import com.dexels.navajo.navascript.FunctionCallLiteral;
import com.dexels.navajo.navascript.FunctionIdentifier;
import com.dexels.navajo.navascript.Ignore;
import com.dexels.navajo.navascript.Include;
import com.dexels.navajo.navascript.InnerBody;
import com.dexels.navajo.navascript.IntType;
import com.dexels.navajo.navascript.KeyValueArgument;
import com.dexels.navajo.navascript.KeyValueArguments;
import com.dexels.navajo.navascript.LengthArgument;
import com.dexels.navajo.navascript.LiteralOrExpression;
import com.dexels.navajo.navascript.Log;
import com.dexels.navajo.navascript.Loop;
import com.dexels.navajo.navascript.Map;
import com.dexels.navajo.navascript.MappableIdentifier;
import com.dexels.navajo.navascript.MappableIdentifierLiteral;
import com.dexels.navajo.navascript.MappedArrayField;
import com.dexels.navajo.navascript.MappedArrayMessage;
import com.dexels.navajo.navascript.MappedMessage;
import com.dexels.navajo.navascript.MemoType;
import com.dexels.navajo.navascript.Message;
import com.dexels.navajo.navascript.MessageArguments;
import com.dexels.navajo.navascript.MessageArray;
import com.dexels.navajo.navascript.MessageArrayElement;
import com.dexels.navajo.navascript.Method;
import com.dexels.navajo.navascript.Methods;
import com.dexels.navajo.navascript.Minus;
import com.dexels.navajo.navascript.MultiOrDiv;
import com.dexels.navajo.navascript.Navascript;
import com.dexels.navajo.navascript.NavascriptPackage;
import com.dexels.navajo.navascript.NullLiteral;
import com.dexels.navajo.navascript.NumberLiteral;
import com.dexels.navajo.navascript.Option;
import com.dexels.navajo.navascript.Overwrite;
import com.dexels.navajo.navascript.PercentageType;
import com.dexels.navajo.navascript.Plus;
import com.dexels.navajo.navascript.Print;
import com.dexels.navajo.navascript.Property;
import com.dexels.navajo.navascript.PropertyArguments;
import com.dexels.navajo.navascript.SelectionArray;
import com.dexels.navajo.navascript.SelectionArrayElement;
import com.dexels.navajo.navascript.SelectionType;
import com.dexels.navajo.navascript.SetterField;
import com.dexels.navajo.navascript.SimpleType;
import com.dexels.navajo.navascript.StringLiteral;
import com.dexels.navajo.navascript.StringType;
import com.dexels.navajo.navascript.SubTypeArgument;
import com.dexels.navajo.navascript.Synchronized;
import com.dexels.navajo.navascript.SynchronizedArgument;
import com.dexels.navajo.navascript.SynchronizedArguments;
import com.dexels.navajo.navascript.TimestampType;
import com.dexels.navajo.navascript.TmlIdentifier;
import com.dexels.navajo.navascript.TmlIdentifierLiteral;
import com.dexels.navajo.navascript.TodayLiteral;
import com.dexels.navajo.navascript.TopLevelStatement;
import com.dexels.navajo.navascript.TopLevelStatements;
import com.dexels.navajo.navascript.TypeArgument;
import com.dexels.navajo.navascript.Validations;
import com.dexels.navajo.navascript.Var;
import com.dexels.navajo.navascript.VarArgument;
import com.dexels.navajo.navascript.VarArguments;
import com.dexels.navajo.navascript.VarArray;
import com.dexels.navajo.navascript.VarArrayElement;
import com.dexels.navajo.navascript.VarElement;
import com.dexels.navajo.navascript.VarMode;
import com.dexels.navajo.navascript.VarType;
import com.dexels.navajo.services.NavascriptGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class NavascriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private NavascriptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == NavascriptPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NavascriptPackage.ADAPTER_METHOD:
				sequence_AdapterMethod(context, (AdapterMethod) semanticObject); 
				return; 
			case NavascriptPackage.AND_OR_EXPRESSION:
				sequence_BooleanExpression(context, (AndOrExpression) semanticObject); 
				return; 
			case NavascriptPackage.ANTI_MESSAGE:
				sequence_AntiMessage(context, (AntiMessage) semanticObject); 
				return; 
			case NavascriptPackage.ARITHMETIC_SIGNED:
				sequence_Prefixed(context, (ArithmeticSigned) semanticObject); 
				return; 
			case NavascriptPackage.ARRAY_ELEMENT_TYPE:
				sequence_MessageType(context, (ArrayElementType) semanticObject); 
				return; 
			case NavascriptPackage.ARRAY_TYPE:
				sequence_MessageType(context, (ArrayType) semanticObject); 
				return; 
			case NavascriptPackage.BINARY_TYPE:
				sequence_PropertyType(context, (BinaryType) semanticObject); 
				return; 
			case NavascriptPackage.BLOCK_STATEMENTS:
				sequence_BlockStatements(context, (BlockStatements) semanticObject); 
				return; 
			case NavascriptPackage.BOOLEAN_LITERAL:
				sequence_Atomic(context, (BooleanLiteral) semanticObject); 
				return; 
			case NavascriptPackage.BOOLEAN_NEGATION:
				sequence_Prefixed(context, (BooleanNegation) semanticObject); 
				return; 
			case NavascriptPackage.BOOLEAN_TYPE:
				sequence_PropertyType(context, (BooleanType) semanticObject); 
				return; 
			case NavascriptPackage.BREAK:
				sequence_Break(context, (Break) semanticObject); 
				return; 
			case NavascriptPackage.BREAK_PARAMETER:
				sequence_BreakParameter(context, (BreakParameter) semanticObject); 
				return; 
			case NavascriptPackage.BREAK_PARAMETERS:
				sequence_BreakParameters(context, (BreakParameters) semanticObject); 
				return; 
			case NavascriptPackage.CARDINALITY_ARGUMENT:
				sequence_CardinalityArgument(context, (CardinalityArgument) semanticObject); 
				return; 
			case NavascriptPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case NavascriptPackage.CHECK_ATTRIBUTE:
				sequence_CheckAttribute(context, (CheckAttribute) semanticObject); 
				return; 
			case NavascriptPackage.CLOCK_TIME_TYPE:
				sequence_PropertyType(context, (ClockTimeType) semanticObject); 
				return; 
			case NavascriptPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case NavascriptPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case NavascriptPackage.CONDITIONAL_EXPRESSIONS:
				sequence_ConditionalExpressions(context, (ConditionalExpressions) semanticObject); 
				return; 
			case NavascriptPackage.CURRENT_IN_DOC:
				sequence_Atomic(context, (CurrentInDoc) semanticObject); 
				return; 
			case NavascriptPackage.CURRENT_OUT_DOC:
				sequence_Atomic(context, (CurrentOutDoc) semanticObject); 
				return; 
			case NavascriptPackage.CURRENT_VAR_DOC:
				sequence_Atomic(context, (CurrentVarDoc) semanticObject); 
				return; 
			case NavascriptPackage.DATE_TYPE:
				sequence_PropertyType(context, (DateType) semanticObject); 
				return; 
			case NavascriptPackage.DEBUG_STATEMENT:
				sequence_DebugStatement(context, (DebugStatement) semanticObject); 
				return; 
			case NavascriptPackage.DEFINE:
				sequence_Define(context, (Define) semanticObject); 
				return; 
			case NavascriptPackage.DESCRIPTION_ARGUMENT:
				sequence_DescriptionArgument(context, (DescriptionArgument) semanticObject); 
				return; 
			case NavascriptPackage.DIRECTION_ARGUMENT:
				sequence_DirectionArgument(context, (DirectionArgument) semanticObject); 
				return; 
			case NavascriptPackage.EQUALS:
				sequence_Equals(context, (Equals) semanticObject); 
				return; 
			case NavascriptPackage.EXPRESSION_LITERAL:
				sequence_Atomic(context, (ExpressionLiteral) semanticObject); 
				return; 
			case NavascriptPackage.FINALLY:
				sequence_Finally(context, (Finally) semanticObject); 
				return; 
			case NavascriptPackage.FLOAT_TYPE:
				sequence_PropertyType(context, (FloatType) semanticObject); 
				return; 
			case NavascriptPackage.FOR_ALL_IDENTIFIER:
				sequence_ForAllIdentifier(context, (ForAllIdentifier) semanticObject); 
				return; 
			case NavascriptPackage.FOR_ALL_LITERAL:
				sequence_Atomic(context, (ForAllLiteral) semanticObject); 
				return; 
			case NavascriptPackage.FUNCTION_CALL_LITERAL:
				sequence_Atomic(context, (FunctionCallLiteral) semanticObject); 
				return; 
			case NavascriptPackage.FUNCTION_IDENTIFIER:
				sequence_FunctionIdentifier(context, (FunctionIdentifier) semanticObject); 
				return; 
			case NavascriptPackage.IGNORE:
				sequence_MessageMode(context, (Ignore) semanticObject); 
				return; 
			case NavascriptPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case NavascriptPackage.INNER_BODY:
				sequence_InnerBody(context, (InnerBody) semanticObject); 
				return; 
			case NavascriptPackage.INT_TYPE:
				sequence_PropertyType(context, (IntType) semanticObject); 
				return; 
			case NavascriptPackage.KEY_VALUE_ARGUMENT:
				sequence_KeyValueArgument(context, (KeyValueArgument) semanticObject); 
				return; 
			case NavascriptPackage.KEY_VALUE_ARGUMENTS:
				sequence_KeyValueArguments(context, (KeyValueArguments) semanticObject); 
				return; 
			case NavascriptPackage.LENGTH_ARGUMENT:
				sequence_LengthArgument(context, (LengthArgument) semanticObject); 
				return; 
			case NavascriptPackage.LITERAL_OR_EXPRESSION:
				sequence_LiteralOrExpression(context, (LiteralOrExpression) semanticObject); 
				return; 
			case NavascriptPackage.LOG:
				sequence_Log(context, (Log) semanticObject); 
				return; 
			case NavascriptPackage.LOOP:
				sequence_Loop(context, (Loop) semanticObject); 
				return; 
			case NavascriptPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case NavascriptPackage.MAPPABLE_IDENTIFIER:
				sequence_MappableIdentifier(context, (MappableIdentifier) semanticObject); 
				return; 
			case NavascriptPackage.MAPPABLE_IDENTIFIER_LITERAL:
				sequence_Atomic(context, (MappableIdentifierLiteral) semanticObject); 
				return; 
			case NavascriptPackage.MAPPED_ARRAY_FIELD:
				sequence_MappedArrayField(context, (MappedArrayField) semanticObject); 
				return; 
			case NavascriptPackage.MAPPED_ARRAY_MESSAGE:
				sequence_MappedArrayMessage(context, (MappedArrayMessage) semanticObject); 
				return; 
			case NavascriptPackage.MAPPED_MESSAGE:
				sequence_MappedMessage(context, (MappedMessage) semanticObject); 
				return; 
			case NavascriptPackage.MEMO_TYPE:
				sequence_PropertyType(context, (MemoType) semanticObject); 
				return; 
			case NavascriptPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case NavascriptPackage.MESSAGE_ARGUMENTS:
				sequence_MessageArguments(context, (MessageArguments) semanticObject); 
				return; 
			case NavascriptPackage.MESSAGE_ARRAY:
				sequence_MessageArray(context, (MessageArray) semanticObject); 
				return; 
			case NavascriptPackage.MESSAGE_ARRAY_ELEMENT:
				sequence_MessageArrayElement(context, (MessageArrayElement) semanticObject); 
				return; 
			case NavascriptPackage.METHOD:
				sequence_Method(context, (Method) semanticObject); 
				return; 
			case NavascriptPackage.METHODS:
				sequence_Methods(context, (Methods) semanticObject); 
				return; 
			case NavascriptPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case NavascriptPackage.MULTI_OR_DIV:
				sequence_Multiplication(context, (MultiOrDiv) semanticObject); 
				return; 
			case NavascriptPackage.NAVASCRIPT:
				sequence_Navascript(context, (Navascript) semanticObject); 
				return; 
			case NavascriptPackage.NULL_LITERAL:
				sequence_Atomic(context, (NullLiteral) semanticObject); 
				return; 
			case NavascriptPackage.NUMBER_LITERAL:
				sequence_Atomic(context, (NumberLiteral) semanticObject); 
				return; 
			case NavascriptPackage.OPTION:
				sequence_Option(context, (Option) semanticObject); 
				return; 
			case NavascriptPackage.OVERWRITE:
				sequence_MessageMode(context, (Overwrite) semanticObject); 
				return; 
			case NavascriptPackage.PERCENTAGE_TYPE:
				sequence_PropertyType(context, (PercentageType) semanticObject); 
				return; 
			case NavascriptPackage.PLUS:
				sequence_Addition(context, (Plus) semanticObject); 
				return; 
			case NavascriptPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case NavascriptPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case NavascriptPackage.PROPERTY_ARGUMENTS:
				sequence_PropertyArguments(context, (PropertyArguments) semanticObject); 
				return; 
			case NavascriptPackage.SELECTION_ARRAY:
				sequence_SelectionArray(context, (SelectionArray) semanticObject); 
				return; 
			case NavascriptPackage.SELECTION_ARRAY_ELEMENT:
				sequence_SelectionArrayElement(context, (SelectionArrayElement) semanticObject); 
				return; 
			case NavascriptPackage.SELECTION_TYPE:
				sequence_PropertyType(context, (SelectionType) semanticObject); 
				return; 
			case NavascriptPackage.SETTER_FIELD:
				sequence_SetterField(context, (SetterField) semanticObject); 
				return; 
			case NavascriptPackage.SIMPLE_TYPE:
				sequence_MessageType(context, (SimpleType) semanticObject); 
				return; 
			case NavascriptPackage.STRING_LITERAL:
				sequence_Atomic(context, (StringLiteral) semanticObject); 
				return; 
			case NavascriptPackage.STRING_TYPE:
				sequence_PropertyType(context, (StringType) semanticObject); 
				return; 
			case NavascriptPackage.SUB_TYPE_ARGUMENT:
				sequence_SubTypeArgument(context, (SubTypeArgument) semanticObject); 
				return; 
			case NavascriptPackage.SYNCHRONIZED:
				sequence_Synchronized(context, (Synchronized) semanticObject); 
				return; 
			case NavascriptPackage.SYNCHRONIZED_ARGUMENT:
				sequence_SynchronizedArgument(context, (SynchronizedArgument) semanticObject); 
				return; 
			case NavascriptPackage.SYNCHRONIZED_ARGUMENTS:
				sequence_SynchronizedArguments(context, (SynchronizedArguments) semanticObject); 
				return; 
			case NavascriptPackage.TIMESTAMP_TYPE:
				sequence_PropertyType(context, (TimestampType) semanticObject); 
				return; 
			case NavascriptPackage.TML_IDENTIFIER:
				if (rule == grammarAccess.getSynchronizedArgumentRule()
						|| rule == grammarAccess.getSTimeoutRule()
						|| rule == grammarAccess.getSBreakOnNoLockRule()
						|| rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getBooleanExpressionRule()
						|| action == grammarAccess.getBooleanExpressionAccess().getAndOrExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0_0()
						|| rule == grammarAccess.getEqualsRule()
						|| action == grammarAccess.getEqualsAccess().getEqualsLeftAction_1_0_0()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0()
						|| action == grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiOrDivLeftAction_1_0_0()
						|| rule == grammarAccess.getPrefixedRule()
						|| rule == grammarAccess.getAtomicRule()) {
					sequence_Atomic(context, (TmlIdentifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTmlIdentifierRule()) {
					sequence_TmlIdentifier(context, (TmlIdentifier) semanticObject); 
					return; 
				}
				else break;
			case NavascriptPackage.TML_IDENTIFIER_LITERAL:
				sequence_Atomic(context, (TmlIdentifierLiteral) semanticObject); 
				return; 
			case NavascriptPackage.TODAY_LITERAL:
				sequence_Atomic(context, (TodayLiteral) semanticObject); 
				return; 
			case NavascriptPackage.TOP_LEVEL_STATEMENT:
				sequence_TopLevelStatement(context, (TopLevelStatement) semanticObject); 
				return; 
			case NavascriptPackage.TOP_LEVEL_STATEMENTS:
				sequence_TopLevelStatements(context, (TopLevelStatements) semanticObject); 
				return; 
			case NavascriptPackage.TYPE_ARGUMENT:
				sequence_TypeArgument(context, (TypeArgument) semanticObject); 
				return; 
			case NavascriptPackage.VALIDATIONS:
				sequence_Validations(context, (Validations) semanticObject); 
				return; 
			case NavascriptPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case NavascriptPackage.VAR_ARGUMENT:
				sequence_VarArgument(context, (VarArgument) semanticObject); 
				return; 
			case NavascriptPackage.VAR_ARGUMENTS:
				sequence_VarArguments(context, (VarArguments) semanticObject); 
				return; 
			case NavascriptPackage.VAR_ARRAY:
				sequence_VarArray(context, (VarArray) semanticObject); 
				return; 
			case NavascriptPackage.VAR_ARRAY_ELEMENT:
				sequence_VarArrayElement(context, (VarArrayElement) semanticObject); 
				return; 
			case NavascriptPackage.VAR_ELEMENT:
				sequence_VarElement(context, (VarElement) semanticObject); 
				return; 
			case NavascriptPackage.VAR_MODE:
				sequence_VarMode(context, (VarMode) semanticObject); 
				return; 
			case NavascriptPackage.VAR_TYPE:
				sequence_VarType(context, (VarType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     MethodOrSetter returns AdapterMethod
	 *     AdapterMethod returns AdapterMethod
	 *
	 * Constraint:
	 *     (method=METHOD_IDENTIFIER arguments=KeyValueArguments?)
	 */
	protected void sequence_AdapterMethod(ISerializationContext context, AdapterMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns Minus
	 *     STimeout returns Minus
	 *     SBreakOnNoLock returns Minus
	 *     Expression returns Minus
	 *     BooleanExpression returns Minus
	 *     BooleanExpression.AndOrExpression_1_0_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0_0 returns Minus
	 *     Equals returns Minus
	 *     Equals.Equals_1_0_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Plus_1_0_0_0 returns Minus
	 *     Addition.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_1_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns Plus
	 *     STimeout returns Plus
	 *     SBreakOnNoLock returns Plus
	 *     Expression returns Plus
	 *     BooleanExpression returns Plus
	 *     BooleanExpression.AndOrExpression_1_0_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0_0 returns Plus
	 *     Equals returns Plus
	 *     Equals.Equals_1_0_0 returns Plus
	 *     Addition returns Plus
	 *     Addition.Plus_1_0_0_0 returns Plus
	 *     Addition.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=Addition_Plus_1_0_0_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AntiMessage returns AntiMessage
	 *
	 * Constraint:
	 *     messageName=QUOTED_IDENTIFIER
	 */
	protected void sequence_AntiMessage(ISerializationContext context, AntiMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.ANTI_MESSAGE__MESSAGE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.ANTI_MESSAGE__MESSAGE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAntiMessageAccess().getMessageNameQUOTED_IDENTIFIERTerminalRuleCall_2_0(), semanticObject.getMessageName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns BooleanLiteral
	 *     STimeout returns BooleanLiteral
	 *     SBreakOnNoLock returns BooleanLiteral
	 *     Expression returns BooleanLiteral
	 *     BooleanExpression returns BooleanLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns BooleanLiteral
	 *     Comparison returns BooleanLiteral
	 *     Comparison.Comparison_1_0_0 returns BooleanLiteral
	 *     Equals returns BooleanLiteral
	 *     Equals.Equals_1_0_0 returns BooleanLiteral
	 *     Addition returns BooleanLiteral
	 *     Addition.Plus_1_0_0_0 returns BooleanLiteral
	 *     Addition.Minus_1_0_1_0 returns BooleanLiteral
	 *     Multiplication returns BooleanLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns BooleanLiteral
	 *     Prefixed returns BooleanLiteral
	 *     Atomic returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value=TRUE | value=FALSE)
	 */
	protected void sequence_Atomic(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns CurrentInDoc
	 *     STimeout returns CurrentInDoc
	 *     SBreakOnNoLock returns CurrentInDoc
	 *     Expression returns CurrentInDoc
	 *     BooleanExpression returns CurrentInDoc
	 *     BooleanExpression.AndOrExpression_1_0_0 returns CurrentInDoc
	 *     Comparison returns CurrentInDoc
	 *     Comparison.Comparison_1_0_0 returns CurrentInDoc
	 *     Equals returns CurrentInDoc
	 *     Equals.Equals_1_0_0 returns CurrentInDoc
	 *     Addition returns CurrentInDoc
	 *     Addition.Plus_1_0_0_0 returns CurrentInDoc
	 *     Addition.Minus_1_0_1_0 returns CurrentInDoc
	 *     Multiplication returns CurrentInDoc
	 *     Multiplication.MultiOrDiv_1_0_0 returns CurrentInDoc
	 *     Prefixed returns CurrentInDoc
	 *     Atomic returns CurrentInDoc
	 *
	 * Constraint:
	 *     value=CURRENT_INDOC
	 */
	protected void sequence_Atomic(ISerializationContext context, CurrentInDoc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.CURRENT_IN_DOC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.CURRENT_IN_DOC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueCURRENT_INDOCTerminalRuleCall_12_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns CurrentOutDoc
	 *     STimeout returns CurrentOutDoc
	 *     SBreakOnNoLock returns CurrentOutDoc
	 *     Expression returns CurrentOutDoc
	 *     BooleanExpression returns CurrentOutDoc
	 *     BooleanExpression.AndOrExpression_1_0_0 returns CurrentOutDoc
	 *     Comparison returns CurrentOutDoc
	 *     Comparison.Comparison_1_0_0 returns CurrentOutDoc
	 *     Equals returns CurrentOutDoc
	 *     Equals.Equals_1_0_0 returns CurrentOutDoc
	 *     Addition returns CurrentOutDoc
	 *     Addition.Plus_1_0_0_0 returns CurrentOutDoc
	 *     Addition.Minus_1_0_1_0 returns CurrentOutDoc
	 *     Multiplication returns CurrentOutDoc
	 *     Multiplication.MultiOrDiv_1_0_0 returns CurrentOutDoc
	 *     Prefixed returns CurrentOutDoc
	 *     Atomic returns CurrentOutDoc
	 *
	 * Constraint:
	 *     value=CURRENT_OUTDOC
	 */
	protected void sequence_Atomic(ISerializationContext context, CurrentOutDoc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.CURRENT_OUT_DOC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.CURRENT_OUT_DOC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueCURRENT_OUTDOCTerminalRuleCall_11_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns CurrentVarDoc
	 *     STimeout returns CurrentVarDoc
	 *     SBreakOnNoLock returns CurrentVarDoc
	 *     Expression returns CurrentVarDoc
	 *     BooleanExpression returns CurrentVarDoc
	 *     BooleanExpression.AndOrExpression_1_0_0 returns CurrentVarDoc
	 *     Comparison returns CurrentVarDoc
	 *     Comparison.Comparison_1_0_0 returns CurrentVarDoc
	 *     Equals returns CurrentVarDoc
	 *     Equals.Equals_1_0_0 returns CurrentVarDoc
	 *     Addition returns CurrentVarDoc
	 *     Addition.Plus_1_0_0_0 returns CurrentVarDoc
	 *     Addition.Minus_1_0_1_0 returns CurrentVarDoc
	 *     Multiplication returns CurrentVarDoc
	 *     Multiplication.MultiOrDiv_1_0_0 returns CurrentVarDoc
	 *     Prefixed returns CurrentVarDoc
	 *     Atomic returns CurrentVarDoc
	 *
	 * Constraint:
	 *     value=CURRENT_VARDOC
	 */
	protected void sequence_Atomic(ISerializationContext context, CurrentVarDoc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.CURRENT_VAR_DOC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.CURRENT_VAR_DOC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueCURRENT_VARDOCTerminalRuleCall_13_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns ExpressionLiteral
	 *     STimeout returns ExpressionLiteral
	 *     SBreakOnNoLock returns ExpressionLiteral
	 *     Expression returns ExpressionLiteral
	 *     BooleanExpression returns ExpressionLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns ExpressionLiteral
	 *     Comparison returns ExpressionLiteral
	 *     Comparison.Comparison_1_0_0 returns ExpressionLiteral
	 *     Equals returns ExpressionLiteral
	 *     Equals.Equals_1_0_0 returns ExpressionLiteral
	 *     Addition returns ExpressionLiteral
	 *     Addition.Plus_1_0_0_0 returns ExpressionLiteral
	 *     Addition.Minus_1_0_1_0 returns ExpressionLiteral
	 *     Multiplication returns ExpressionLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns ExpressionLiteral
	 *     Prefixed returns ExpressionLiteral
	 *     Atomic returns ExpressionLiteral
	 *
	 * Constraint:
	 *     value=Expression
	 */
	protected void sequence_Atomic(ISerializationContext context, ExpressionLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.EXPRESSION_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.EXPRESSION_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueExpressionParserRuleCall_0_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns ForAllLiteral
	 *     STimeout returns ForAllLiteral
	 *     SBreakOnNoLock returns ForAllLiteral
	 *     Expression returns ForAllLiteral
	 *     BooleanExpression returns ForAllLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns ForAllLiteral
	 *     Comparison returns ForAllLiteral
	 *     Comparison.Comparison_1_0_0 returns ForAllLiteral
	 *     Equals returns ForAllLiteral
	 *     Equals.Equals_1_0_0 returns ForAllLiteral
	 *     Addition returns ForAllLiteral
	 *     Addition.Plus_1_0_0_0 returns ForAllLiteral
	 *     Addition.Minus_1_0_1_0 returns ForAllLiteral
	 *     Multiplication returns ForAllLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns ForAllLiteral
	 *     Prefixed returns ForAllLiteral
	 *     Atomic returns ForAllLiteral
	 *
	 * Constraint:
	 *     value=ForAllIdentifier
	 */
	protected void sequence_Atomic(ISerializationContext context, ForAllLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.FOR_ALL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.FOR_ALL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueForAllIdentifierParserRuleCall_8_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns FunctionCallLiteral
	 *     STimeout returns FunctionCallLiteral
	 *     SBreakOnNoLock returns FunctionCallLiteral
	 *     Expression returns FunctionCallLiteral
	 *     BooleanExpression returns FunctionCallLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns FunctionCallLiteral
	 *     Comparison returns FunctionCallLiteral
	 *     Comparison.Comparison_1_0_0 returns FunctionCallLiteral
	 *     Equals returns FunctionCallLiteral
	 *     Equals.Equals_1_0_0 returns FunctionCallLiteral
	 *     Addition returns FunctionCallLiteral
	 *     Addition.Plus_1_0_0_0 returns FunctionCallLiteral
	 *     Addition.Minus_1_0_1_0 returns FunctionCallLiteral
	 *     Multiplication returns FunctionCallLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns FunctionCallLiteral
	 *     Prefixed returns FunctionCallLiteral
	 *     Atomic returns FunctionCallLiteral
	 *
	 * Constraint:
	 *     value=FunctionIdentifier
	 */
	protected void sequence_Atomic(ISerializationContext context, FunctionCallLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.FUNCTION_CALL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.FUNCTION_CALL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueFunctionIdentifierParserRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns MappableIdentifierLiteral
	 *     STimeout returns MappableIdentifierLiteral
	 *     SBreakOnNoLock returns MappableIdentifierLiteral
	 *     Expression returns MappableIdentifierLiteral
	 *     BooleanExpression returns MappableIdentifierLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns MappableIdentifierLiteral
	 *     Comparison returns MappableIdentifierLiteral
	 *     Comparison.Comparison_1_0_0 returns MappableIdentifierLiteral
	 *     Equals returns MappableIdentifierLiteral
	 *     Equals.Equals_1_0_0 returns MappableIdentifierLiteral
	 *     Addition returns MappableIdentifierLiteral
	 *     Addition.Plus_1_0_0_0 returns MappableIdentifierLiteral
	 *     Addition.Minus_1_0_1_0 returns MappableIdentifierLiteral
	 *     Multiplication returns MappableIdentifierLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns MappableIdentifierLiteral
	 *     Prefixed returns MappableIdentifierLiteral
	 *     Atomic returns MappableIdentifierLiteral
	 *
	 * Constraint:
	 *     value=MappableIdentifier
	 */
	protected void sequence_Atomic(ISerializationContext context, MappableIdentifierLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.MAPPABLE_IDENTIFIER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.MAPPABLE_IDENTIFIER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueMappableIdentifierParserRuleCall_5_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns NullLiteral
	 *     STimeout returns NullLiteral
	 *     SBreakOnNoLock returns NullLiteral
	 *     Expression returns NullLiteral
	 *     BooleanExpression returns NullLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns NullLiteral
	 *     Comparison returns NullLiteral
	 *     Comparison.Comparison_1_0_0 returns NullLiteral
	 *     Equals returns NullLiteral
	 *     Equals.Equals_1_0_0 returns NullLiteral
	 *     Addition returns NullLiteral
	 *     Addition.Plus_1_0_0_0 returns NullLiteral
	 *     Addition.Minus_1_0_1_0 returns NullLiteral
	 *     Multiplication returns NullLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns NullLiteral
	 *     Prefixed returns NullLiteral
	 *     Atomic returns NullLiteral
	 *
	 * Constraint:
	 *     value=NULL_DEF
	 */
	protected void sequence_Atomic(ISerializationContext context, NullLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.NULL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.NULL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueNULL_DEFTerminalRuleCall_9_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns NumberLiteral
	 *     STimeout returns NumberLiteral
	 *     SBreakOnNoLock returns NumberLiteral
	 *     Expression returns NumberLiteral
	 *     BooleanExpression returns NumberLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns NumberLiteral
	 *     Comparison returns NumberLiteral
	 *     Comparison.Comparison_1_0_0 returns NumberLiteral
	 *     Equals returns NumberLiteral
	 *     Equals.Equals_1_0_0 returns NumberLiteral
	 *     Addition returns NumberLiteral
	 *     Addition.Plus_1_0_0_0 returns NumberLiteral
	 *     Addition.Minus_1_0_1_0 returns NumberLiteral
	 *     Multiplication returns NumberLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns NumberLiteral
	 *     Prefixed returns NumberLiteral
	 *     Atomic returns NumberLiteral
	 *
	 * Constraint:
	 *     (value=INTEGER | value=ONE | value=FLOAT)
	 */
	protected void sequence_Atomic(ISerializationContext context, NumberLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns StringLiteral
	 *     STimeout returns StringLiteral
	 *     SBreakOnNoLock returns StringLiteral
	 *     Expression returns StringLiteral
	 *     BooleanExpression returns StringLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0_0 returns StringLiteral
	 *     Equals returns StringLiteral
	 *     Equals.Equals_1_0_0 returns StringLiteral
	 *     Addition returns StringLiteral
	 *     Addition.Plus_1_0_0_0 returns StringLiteral
	 *     Addition.Minus_1_0_1_0 returns StringLiteral
	 *     Multiplication returns StringLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns StringLiteral
	 *     Prefixed returns StringLiteral
	 *     Atomic returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING_LITERAL
	 */
	protected void sequence_Atomic(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRING_LITERALTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns TmlIdentifier
	 *     STimeout returns TmlIdentifier
	 *     SBreakOnNoLock returns TmlIdentifier
	 *     Expression returns TmlIdentifier
	 *     BooleanExpression returns TmlIdentifier
	 *     BooleanExpression.AndOrExpression_1_0_0 returns TmlIdentifier
	 *     Comparison returns TmlIdentifier
	 *     Comparison.Comparison_1_0_0 returns TmlIdentifier
	 *     Equals returns TmlIdentifier
	 *     Equals.Equals_1_0_0 returns TmlIdentifier
	 *     Addition returns TmlIdentifier
	 *     Addition.Plus_1_0_0_0 returns TmlIdentifier
	 *     Addition.Minus_1_0_1_0 returns TmlIdentifier
	 *     Multiplication returns TmlIdentifier
	 *     Multiplication.MultiOrDiv_1_0_0 returns TmlIdentifier
	 *     Prefixed returns TmlIdentifier
	 *     Atomic returns TmlIdentifier
	 *
	 * Constraint:
	 *     value=TmlIdentifier
	 */
	protected void sequence_Atomic(ISerializationContext context, TmlIdentifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.TML_IDENTIFIER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.TML_IDENTIFIER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueTmlIdentifierParserRuleCall_7_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns TmlIdentifierLiteral
	 *     STimeout returns TmlIdentifierLiteral
	 *     SBreakOnNoLock returns TmlIdentifierLiteral
	 *     Expression returns TmlIdentifierLiteral
	 *     BooleanExpression returns TmlIdentifierLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns TmlIdentifierLiteral
	 *     Comparison returns TmlIdentifierLiteral
	 *     Comparison.Comparison_1_0_0 returns TmlIdentifierLiteral
	 *     Equals returns TmlIdentifierLiteral
	 *     Equals.Equals_1_0_0 returns TmlIdentifierLiteral
	 *     Addition returns TmlIdentifierLiteral
	 *     Addition.Plus_1_0_0_0 returns TmlIdentifierLiteral
	 *     Addition.Minus_1_0_1_0 returns TmlIdentifierLiteral
	 *     Multiplication returns TmlIdentifierLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns TmlIdentifierLiteral
	 *     Prefixed returns TmlIdentifierLiteral
	 *     Atomic returns TmlIdentifierLiteral
	 *
	 * Constraint:
	 *     (hasExists?='?'? value=TmlIdentifier)
	 */
	protected void sequence_Atomic(ISerializationContext context, TmlIdentifierLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns TodayLiteral
	 *     STimeout returns TodayLiteral
	 *     SBreakOnNoLock returns TodayLiteral
	 *     Expression returns TodayLiteral
	 *     BooleanExpression returns TodayLiteral
	 *     BooleanExpression.AndOrExpression_1_0_0 returns TodayLiteral
	 *     Comparison returns TodayLiteral
	 *     Comparison.Comparison_1_0_0 returns TodayLiteral
	 *     Equals returns TodayLiteral
	 *     Equals.Equals_1_0_0 returns TodayLiteral
	 *     Addition returns TodayLiteral
	 *     Addition.Plus_1_0_0_0 returns TodayLiteral
	 *     Addition.Minus_1_0_1_0 returns TodayLiteral
	 *     Multiplication returns TodayLiteral
	 *     Multiplication.MultiOrDiv_1_0_0 returns TodayLiteral
	 *     Prefixed returns TodayLiteral
	 *     Atomic returns TodayLiteral
	 *
	 * Constraint:
	 *     value=TODAY
	 */
	protected void sequence_Atomic(ISerializationContext context, TodayLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.TODAY_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.TODAY_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueTODAYTerminalRuleCall_10_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatements returns BlockStatements
	 *
	 * Constraint:
	 *     statements+=InnerBody*
	 */
	protected void sequence_BlockStatements(ISerializationContext context, BlockStatements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns AndOrExpression
	 *     STimeout returns AndOrExpression
	 *     SBreakOnNoLock returns AndOrExpression
	 *     Expression returns AndOrExpression
	 *     BooleanExpression returns AndOrExpression
	 *     BooleanExpression.AndOrExpression_1_0_0 returns AndOrExpression
	 *
	 * Constraint:
	 *     (left=BooleanExpression_AndOrExpression_1_0_0 (op='OR' | op='AND') right=Comparison)
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, AndOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BreakParameter returns BreakParameter
	 *
	 * Constraint:
	 *     (code=LiteralOrExpression | description=LiteralOrExpression)
	 */
	protected void sequence_BreakParameter(ISerializationContext context, BreakParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BreakParameters returns BreakParameters
	 *
	 * Constraint:
	 *     (parameters+=BreakParameter parameters+=BreakParameter*)
	 */
	protected void sequence_BreakParameters(ISerializationContext context, BreakParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Break returns Break
	 *
	 * Constraint:
	 *     parameters=BreakParameters?
	 */
	protected void sequence_Break(ISerializationContext context, Break semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyArgument returns CardinalityArgument
	 *     CardinalityArgument returns CardinalityArgument
	 *
	 * Constraint:
	 *     (value='+' | value=ONE)
	 */
	protected void sequence_CardinalityArgument(ISerializationContext context, CardinalityArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CheckAttribute returns CheckAttribute
	 *
	 * Constraint:
	 *     (value=LiteralOrExpression | value=LiteralOrExpression)
	 */
	protected void sequence_CheckAttribute(ISerializationContext context, CheckAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Check returns Check
	 *
	 * Constraint:
	 *     (condition=Expression? checkAttributes+=CheckAttribute checkAttributes+=CheckAttribute? expression=Expression)
	 */
	protected void sequence_Check(ISerializationContext context, Check semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns Comparison
	 *     STimeout returns Comparison
	 *     SBreakOnNoLock returns Comparison
	 *     Expression returns Comparison
	 *     BooleanExpression returns Comparison
	 *     BooleanExpression.AndOrExpression_1_0_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0_0 (op='<' | op='>' | op='<=' | op='>=') right=Equals)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=Expression expression=LiteralOrExpression)
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.CONDITIONAL_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getExpressionLiteralOrExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpressions returns ConditionalExpressions
	 *
	 * Constraint:
	 *     ((conditionalExpressions+=ConditionalExpression+ elseExpresssion=LiteralOrExpression) | singleExpression=LiteralOrExpression)
	 */
	protected void sequence_ConditionalExpressions(ISerializationContext context, ConditionalExpressions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DebugStatement returns DebugStatement
	 *
	 * Constraint:
	 *     (value='all' | value='request' | value='response')
	 */
	protected void sequence_DebugStatement(ISerializationContext context, DebugStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Define returns Define
	 *
	 * Constraint:
	 *     (defineKey=QUOTED_IDENTIFIER expression=Expression)
	 */
	protected void sequence_Define(ISerializationContext context, Define semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.DEFINE__DEFINE_KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.DEFINE__DEFINE_KEY));
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.DEFINE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.DEFINE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefineAccess().getDefineKeyQUOTED_IDENTIFIERTerminalRuleCall_2_0(), semanticObject.getDefineKey());
		feeder.accept(grammarAccess.getDefineAccess().getExpressionExpressionParserRuleCall_4_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyArgument returns DescriptionArgument
	 *     DescriptionArgument returns DescriptionArgument
	 *
	 * Constraint:
	 *     value=LiteralOrExpression
	 */
	protected void sequence_DescriptionArgument(ISerializationContext context, DescriptionArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.DESCRIPTION_ARGUMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.DESCRIPTION_ARGUMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDescriptionArgumentAccess().getValueLiteralOrExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyArgument returns DirectionArgument
	 *     DirectionArgument returns DirectionArgument
	 *
	 * Constraint:
	 *     (value='in' | value='out' | value='inout')
	 */
	protected void sequence_DirectionArgument(ISerializationContext context, DirectionArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns Equals
	 *     STimeout returns Equals
	 *     SBreakOnNoLock returns Equals
	 *     Expression returns Equals
	 *     BooleanExpression returns Equals
	 *     BooleanExpression.AndOrExpression_1_0_0 returns Equals
	 *     Comparison returns Equals
	 *     Comparison.Comparison_1_0_0 returns Equals
	 *     Equals returns Equals
	 *     Equals.Equals_1_0_0 returns Equals
	 *
	 * Constraint:
	 *     (left=Equals_Equals_1_0_0 (op='==' | op='!=') right=Addition)
	 */
	protected void sequence_Equals(ISerializationContext context, Equals semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Finally returns Finally
	 *
	 * Constraint:
	 *     finallyStatements=TopLevelStatements
	 */
	protected void sequence_Finally(ISerializationContext context, Finally semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.FINALLY__FINALLY_STATEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.FINALLY__FINALLY_STATEMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFinallyAccess().getFinallyStatementsTopLevelStatementsParserRuleCall_3_0(), semanticObject.getFinallyStatements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForAllIdentifier returns ForAllIdentifier
	 *
	 * Constraint:
	 *     ((op=FORALL | op=EXISTS) expression=Expression messagedefinition=STRING_LITERAL)
	 */
	protected void sequence_ForAllIdentifier(ISerializationContext context, ForAllIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionIdentifier returns FunctionIdentifier
	 *
	 * Constraint:
	 *     (func=IDENTIFIER (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_FunctionIdentifier(ISerializationContext context, FunctionIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Include returns Include
	 *
	 * Constraint:
	 *     scriptName=QUOTED_IDENTIFIER
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.INCLUDE__SCRIPT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.INCLUDE__SCRIPT_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getScriptNameQUOTED_IDENTIFIERTerminalRuleCall_2_0(), semanticObject.getScriptName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InnerBody returns InnerBody
	 *
	 * Constraint:
	 *     (
	 *         condition=Expression? 
	 *         (
	 *             statement=Property | 
	 *             statement=Option | 
	 *             statement=MethodOrSetter | 
	 *             statement=Message | 
	 *             statement=AntiMessage | 
	 *             statement=Include | 
	 *             statement=Methods | 
	 *             statement=Var | 
	 *             statement=Print | 
	 *             statement=Log | 
	 *             statement=Define | 
	 *             statement=Loop | 
	 *             statement=Map | 
	 *             statement=Break | 
	 *             statement=Synchronized | 
	 *             statement=BlockStatements
	 *         )
	 *     )
	 */
	protected void sequence_InnerBody(ISerializationContext context, InnerBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValueArgument returns KeyValueArgument
	 *
	 * Constraint:
	 *     ((key=IDENTIFIER | key=OPTION_TYPE) value=LiteralOrExpression)
	 */
	protected void sequence_KeyValueArgument(ISerializationContext context, KeyValueArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KeyValueArguments returns KeyValueArguments
	 *
	 * Constraint:
	 *     (keyValueArguments+=KeyValueArgument keyValueArguments+=KeyValueArgument*)
	 */
	protected void sequence_KeyValueArguments(ISerializationContext context, KeyValueArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyArgument returns LengthArgument
	 *     LengthArgument returns LengthArgument
	 *
	 * Constraint:
	 *     value=INTEGER
	 */
	protected void sequence_LengthArgument(ISerializationContext context, LengthArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.LENGTH_ARGUMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.LENGTH_ARGUMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLengthArgumentAccess().getValueINTEGERTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns LiteralOrExpression
	 *     SKey returns LiteralOrExpression
	 *     BreakParameter returns LiteralOrExpression
	 *     LiteralOrExpression returns LiteralOrExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_LiteralOrExpression(ISerializationContext context, LiteralOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.LITERAL_OR_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.LITERAL_OR_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralOrExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Log returns Log
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Log(ISerializationContext context, Log semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.LOG__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.LOG__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Loop returns Loop
	 *
	 * Constraint:
	 *     ((mappable=MAPPABLE_IDENTIFIER | tml=TmlIdentifier) filter=Expression? statements+=InnerBody*)
	 */
	protected void sequence_Loop(ISerializationContext context, Loop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (((adapterName=IDENTIFIER arguments=KeyValueArguments?) | (objectName=OBJECT_IDENTIFIER arguments=KeyValueArguments?)) statements+=InnerBody*)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappableIdentifier returns MappableIdentifier
	 *
	 * Constraint:
	 *     (field=MAPPABLE_IDENTIFIER (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_MappableIdentifier(ISerializationContext context, MappableIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappedArrayField returns MappedArrayField
	 *
	 * Constraint:
	 *     (field=MAPPABLE_IDENTIFIER filter=Expression? statements+=InnerBody*)
	 */
	protected void sequence_MappedArrayField(ISerializationContext context, MappedArrayField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappedArrayMessage returns MappedArrayMessage
	 *
	 * Constraint:
	 *     (
	 *         (message=CURRENT_OUTDOC | message=CURRENT_INDOC | message=CURRENT_VARDOC | message=TML_LITERAL | message=QUOTED_IDENTIFIER) 
	 *         filter=Expression? 
	 *         statements+=InnerBody*
	 *     )
	 */
	protected void sequence_MappedArrayMessage(ISerializationContext context, MappedArrayMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappedMessage returns MappedMessage
	 *
	 * Constraint:
	 *     statements+=InnerBody*
	 */
	protected void sequence_MappedMessage(ISerializationContext context, MappedMessage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArguments returns MessageArguments
	 *
	 * Constraint:
	 *     (arguments+=MessageArgument arguments+=MessageArgument*)
	 */
	protected void sequence_MessageArguments(ISerializationContext context, MessageArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArrayElement returns MessageArrayElement
	 *
	 * Constraint:
	 *     statements+=InnerBody*
	 */
	protected void sequence_MessageArrayElement(ISerializationContext context, MessageArrayElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArray returns MessageArray
	 *
	 * Constraint:
	 *     (arrayMessageElements+=MessageArrayElement arrayMessageElements+=MessageArrayElement*)
	 */
	protected void sequence_MessageArray(ISerializationContext context, MessageArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArgument returns Ignore
	 *     MessageMode returns Ignore
	 *
	 * Constraint:
	 *     {Ignore}
	 */
	protected void sequence_MessageMode(ISerializationContext context, Ignore semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArgument returns Overwrite
	 *     MessageMode returns Overwrite
	 *
	 * Constraint:
	 *     {Overwrite}
	 */
	protected void sequence_MessageMode(ISerializationContext context, Overwrite semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArgument returns ArrayElementType
	 *     MessageType returns ArrayElementType
	 *
	 * Constraint:
	 *     {ArrayElementType}
	 */
	protected void sequence_MessageType(ISerializationContext context, ArrayElementType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArgument returns ArrayType
	 *     MessageType returns ArrayType
	 *
	 * Constraint:
	 *     {ArrayType}
	 */
	protected void sequence_MessageType(ISerializationContext context, ArrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MessageArgument returns SimpleType
	 *     MessageType returns SimpleType
	 *
	 * Constraint:
	 *     {SimpleType}
	 */
	protected void sequence_MessageType(ISerializationContext context, SimpleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (
	 *         messageName=QUOTED_IDENTIFIER 
	 *         arguments=MessageArguments? 
	 *         (statements+=InnerBody+ | arrayField=MappedArrayField | arrayMessage=MappedArrayMessage | messageArray=MessageArray)?
	 *     )
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Method returns Method
	 *
	 * Constraint:
	 *     methodName=QUOTED_IDENTIFIER
	 */
	protected void sequence_Method(ISerializationContext context, Method semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.METHOD__METHOD_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.METHOD__METHOD_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMethodAccess().getMethodNameQUOTED_IDENTIFIERTerminalRuleCall_1_0(), semanticObject.getMethodName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Methods returns Methods
	 *
	 * Constraint:
	 *     methods+=Method*
	 */
	protected void sequence_Methods(ISerializationContext context, Methods semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns MultiOrDiv
	 *     STimeout returns MultiOrDiv
	 *     SBreakOnNoLock returns MultiOrDiv
	 *     Expression returns MultiOrDiv
	 *     BooleanExpression returns MultiOrDiv
	 *     BooleanExpression.AndOrExpression_1_0_0 returns MultiOrDiv
	 *     Comparison returns MultiOrDiv
	 *     Comparison.Comparison_1_0_0 returns MultiOrDiv
	 *     Equals returns MultiOrDiv
	 *     Equals.Equals_1_0_0 returns MultiOrDiv
	 *     Addition returns MultiOrDiv
	 *     Addition.Plus_1_0_0_0 returns MultiOrDiv
	 *     Addition.Minus_1_0_1_0 returns MultiOrDiv
	 *     Multiplication returns MultiOrDiv
	 *     Multiplication.MultiOrDiv_1_0_0 returns MultiOrDiv
	 *
	 * Constraint:
	 *     (left=Multiplication_MultiOrDiv_1_0_0 (op='*' | op='/') right=Prefixed)
	 */
	protected void sequence_Multiplication(ISerializationContext context, MultiOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Navascript returns Navascript
	 *
	 * Constraint:
	 *     (debug=DebugStatement? validations=Validations? toplevelStatements=TopLevelStatements finally=Finally?)
	 */
	protected void sequence_Navascript(ISerializationContext context, Navascript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns Option
	 *
	 * Constraint:
	 *     (option=OPTION_TYPE expressionList=ConditionalExpressions)
	 */
	protected void sequence_Option(ISerializationContext context, Option semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.OPTION__OPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.OPTION__OPTION));
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.OPTION__EXPRESSION_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.OPTION__EXPRESSION_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionAccess().getOptionOPTION_TYPEParserRuleCall_1_0(), semanticObject.getOption());
		feeder.accept(grammarAccess.getOptionAccess().getExpressionListConditionalExpressionsParserRuleCall_3_0(), semanticObject.getExpressionList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns ArithmeticSigned
	 *     STimeout returns ArithmeticSigned
	 *     SBreakOnNoLock returns ArithmeticSigned
	 *     Expression returns ArithmeticSigned
	 *     BooleanExpression returns ArithmeticSigned
	 *     BooleanExpression.AndOrExpression_1_0_0 returns ArithmeticSigned
	 *     Comparison returns ArithmeticSigned
	 *     Comparison.Comparison_1_0_0 returns ArithmeticSigned
	 *     Equals returns ArithmeticSigned
	 *     Equals.Equals_1_0_0 returns ArithmeticSigned
	 *     Addition returns ArithmeticSigned
	 *     Addition.Plus_1_0_0_0 returns ArithmeticSigned
	 *     Addition.Minus_1_0_1_0 returns ArithmeticSigned
	 *     Multiplication returns ArithmeticSigned
	 *     Multiplication.MultiOrDiv_1_0_0 returns ArithmeticSigned
	 *     Prefixed returns ArithmeticSigned
	 *
	 * Constraint:
	 *     expression=Atomic
	 */
	protected void sequence_Prefixed(ISerializationContext context, ArithmeticSigned semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.ARITHMETIC_SIGNED__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.ARITHMETIC_SIGNED__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixedAccess().getExpressionAtomicParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns BooleanNegation
	 *     STimeout returns BooleanNegation
	 *     SBreakOnNoLock returns BooleanNegation
	 *     Expression returns BooleanNegation
	 *     BooleanExpression returns BooleanNegation
	 *     BooleanExpression.AndOrExpression_1_0_0 returns BooleanNegation
	 *     Comparison returns BooleanNegation
	 *     Comparison.Comparison_1_0_0 returns BooleanNegation
	 *     Equals returns BooleanNegation
	 *     Equals.Equals_1_0_0 returns BooleanNegation
	 *     Addition returns BooleanNegation
	 *     Addition.Plus_1_0_0_0 returns BooleanNegation
	 *     Addition.Minus_1_0_1_0 returns BooleanNegation
	 *     Multiplication returns BooleanNegation
	 *     Multiplication.MultiOrDiv_1_0_0 returns BooleanNegation
	 *     Prefixed returns BooleanNegation
	 *
	 * Constraint:
	 *     expression=Atomic
	 */
	protected void sequence_Prefixed(ISerializationContext context, BooleanNegation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.BOOLEAN_NEGATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.BOOLEAN_NEGATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrefixedAccess().getExpressionAtomicParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Print returns Print
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.PRINT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.PRINT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyArguments returns PropertyArguments
	 *
	 * Constraint:
	 *     (arguments+=PropertyArgument arguments+=PropertyArgument*)
	 */
	protected void sequence_PropertyArguments(ISerializationContext context, PropertyArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns BinaryType
	 *
	 * Constraint:
	 *     {BinaryType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, BinaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns BooleanType
	 *
	 * Constraint:
	 *     {BooleanType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns ClockTimeType
	 *
	 * Constraint:
	 *     {ClockTimeType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, ClockTimeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns DateType
	 *
	 * Constraint:
	 *     {DateType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, DateType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns FloatType
	 *
	 * Constraint:
	 *     {FloatType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, FloatType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns IntType
	 *
	 * Constraint:
	 *     {IntType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, IntType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns MemoType
	 *
	 * Constraint:
	 *     {MemoType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, MemoType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns PercentageType
	 *
	 * Constraint:
	 *     {PercentageType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, PercentageType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns SelectionType
	 *
	 * Constraint:
	 *     {SelectionType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, SelectionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyType returns TimestampType
	 *
	 * Constraint:
	 *     {TimestampType}
	 */
	protected void sequence_PropertyType(ISerializationContext context, TimestampType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (
	 *         propertyName=QUOTED_IDENTIFIER 
	 *         arguments=PropertyArguments? 
	 *         (expressionList=ConditionalExpressions | selectionArray=SelectionArray | arrayField=MappedArrayField | arrayMessage=MappedArrayMessage)?
	 *     )
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectionArrayElement returns SelectionArrayElement
	 *
	 * Constraint:
	 *     innerBody+=InnerBody*
	 */
	protected void sequence_SelectionArrayElement(ISerializationContext context, SelectionArrayElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectionArray returns SelectionArray
	 *
	 * Constraint:
	 *     (arrayElements+=SelectionArrayElement arrayElements+=SelectionArrayElement*)
	 */
	protected void sequence_SelectionArray(ISerializationContext context, SelectionArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MethodOrSetter returns SetterField
	 *     SetterField returns SetterField
	 *
	 * Constraint:
	 *     (
	 *         field=MAPPABLE_IDENTIFIER 
	 *         (
	 *             expressionList=ConditionalExpressions | 
	 *             (arguments=KeyValueArguments? mappedArray=MappedArrayMessage) | 
	 *             mappedField=MappedArrayField | 
	 *             mappedMessage=MappedMessage
	 *         )
	 *     )
	 */
	protected void sequence_SetterField(ISerializationContext context, SetterField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyArgument returns SubTypeArgument
	 *     SubTypeArgument returns SubTypeArgument
	 *
	 * Constraint:
	 *     value=IDENTIFIER
	 */
	protected void sequence_SubTypeArgument(ISerializationContext context, SubTypeArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.SUB_TYPE_ARGUMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.SUB_TYPE_ARGUMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubTypeArgumentAccess().getValueIDENTIFIERTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArgument returns SynchronizedArgument
	 *
	 * Constraint:
	 *     {SynchronizedArgument}
	 */
	protected void sequence_SynchronizedArgument(ISerializationContext context, SynchronizedArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SynchronizedArguments returns SynchronizedArguments
	 *
	 * Constraint:
	 *     (arguments+=SynchronizedArgument arguments+=SynchronizedArgument*)
	 */
	protected void sequence_SynchronizedArguments(ISerializationContext context, SynchronizedArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Synchronized returns Synchronized
	 *
	 * Constraint:
	 *     (arguments=SynchronizedArguments statements+=TopLevelStatement*)
	 */
	protected void sequence_Synchronized(ISerializationContext context, Synchronized semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TmlIdentifier returns TmlIdentifier
	 *
	 * Constraint:
	 *     (tml=TML_LITERAL | tml=QUOTED_IDENTIFIER)
	 */
	protected void sequence_TmlIdentifier(ISerializationContext context, TmlIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelStatement returns TopLevelStatement
	 *
	 * Constraint:
	 *     (
	 *         condition=Expression? 
	 *         (
	 *             statement=Message | 
	 *             statement=Var | 
	 *             statement=Map | 
	 *             statement=AntiMessage | 
	 *             statement=Define | 
	 *             statement=Print | 
	 *             statement=Log | 
	 *             statement=Loop | 
	 *             statement=Methods | 
	 *             statement=Include | 
	 *             statement=Break | 
	 *             statement=Synchronized | 
	 *             statement=BlockStatements
	 *         )
	 *     )
	 */
	protected void sequence_TopLevelStatement(ISerializationContext context, TopLevelStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelStatements returns TopLevelStatements
	 *
	 * Constraint:
	 *     statements+=TopLevelStatement*
	 */
	protected void sequence_TopLevelStatements(ISerializationContext context, TopLevelStatements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyArgument returns TypeArgument
	 *     TypeArgument returns TypeArgument
	 *
	 * Constraint:
	 *     value=PropertyType
	 */
	protected void sequence_TypeArgument(ISerializationContext context, TypeArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.TYPE_ARGUMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.TYPE_ARGUMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeArgumentAccess().getValuePropertyTypeParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Validations returns Validations
	 *
	 * Constraint:
	 *     checks+=Check*
	 */
	protected void sequence_Validations(ISerializationContext context, Validations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarArgument returns VarArgument
	 *
	 * Constraint:
	 *     (argument=VarType | argument=VarMode)
	 */
	protected void sequence_VarArgument(ISerializationContext context, VarArgument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarArguments returns VarArguments
	 *
	 * Constraint:
	 *     (varArguments+=VarArgument varArguments+=VarArgument*)
	 */
	protected void sequence_VarArguments(ISerializationContext context, VarArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarArrayElement returns VarArrayElement
	 *
	 * Constraint:
	 *     varElements+=VarElement*
	 */
	protected void sequence_VarArrayElement(ISerializationContext context, VarArrayElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarArray returns VarArray
	 *
	 * Constraint:
	 *     (vararrayelement+=VarArrayElement vararrayelement+=VarArrayElement*)
	 */
	protected void sequence_VarArray(ISerializationContext context, VarArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarElement returns VarElement
	 *
	 * Constraint:
	 *     (condition=Expression? var=Var)
	 */
	protected void sequence_VarElement(ISerializationContext context, VarElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarMode returns VarMode
	 *
	 * Constraint:
	 *     mode=MessageMode
	 */
	protected void sequence_VarMode(ISerializationContext context, VarMode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NavascriptPackage.Literals.VAR_MODE__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NavascriptPackage.Literals.VAR_MODE__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarModeAccess().getModeMessageModeParserRuleCall_3_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarType returns VarType
	 *
	 * Constraint:
	 *     (type=MessageType | type=PropertyType)
	 */
	protected void sequence_VarType(ISerializationContext context, VarType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (
	 *         varName='/'? 
	 *         arguments=VarArguments? 
	 *         (
	 *             expressionList=ConditionalExpressions | 
	 *             varArray=VarArray | 
	 *             varElements+=VarElement+ | 
	 *             mappedArrayField=MappedArrayField | 
	 *             mappedArrayMessage=MappedArrayMessage
	 *         )?
	 *     )
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
